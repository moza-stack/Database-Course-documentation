
Schema changes may be difficult in highly dynamic environments.
| **Aspect**          | **Flat File Systems**                                                                        | **Relational Databases (RDBMS)**                                                        |
| ------------------- | -------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| **Structure**       | Data stored in plain text, CSV, or simple files; no enforced schema; one table per file      | Data stored in structured tables with rows/columns; schema enforced through constraints |
| **Data Redundancy** | High redundancy; repeated data across files                                                  | Low redundancy due to normalization and constraint enforcement                          |
| **Relationships**   | No built-in support; relationships handled manually                                          | Supports primary/foreign keys, joins, and multiple relationship types                   |
| **Example Usage**   | Small datasets, logs, configs, simple applications, CSV/JSON files                           | Enterprise systems, banking, hospitals, ERPs, multi-user applications                   |
| **Drawbacks**       | Poor scalability, no integrity rules, difficult relationship management, inefficient queries | Requires setup and maintenance, resource-heavy, needs database administration knowledge |



"3"

1. System Analyst

A System Analyst studies an organization‚Äôs processes and identifies what the system or software must do.

Key Responsibilities:

Gather and analyze business requirements

Create system specifications and workflow diagrams

Act as a bridge between business users and technical teams

Ensure the final system meets business needs

2. Database Designer

A Database Designer is responsible for planning how data will be stored, organized, and related.

Key Responsibilities:

Design the database schema (tables, relationships, constraints)

Normalize data to reduce redundancy

Ensure the model supports performance, security, and scalability

Work closely with system analysts and developers to align with requirements

3. Database Developer

A Database Developer builds and maintains the database components.

Key Responsibilities:

Write SQL queries, stored procedures, triggers, and functions

Implement the database design into an actual DBMS

Optimize queries for speed

Assist with integration between the database and applications

4. DBA (Database Administrator)

A Database Administrator manages, secures, and maintains the database after it is built.

Key Responsibilities:

Install, configure, and update the DBMS

Monitor performance and troubleshoot issues

Manage backups, recovery plans, and security controls

Control user access and permissions

Ensure availability and reliability of databases

5. Application Developer

An Application Developer builds the actual applications that use the database.

Key Responsibilities:

Develop front-end and/or back-end application logic

Integrate application code with the database

Implement user interfaces and workflows

Test and debug the application

Work with database developers to ensure efficient data access

6. BI (Business Intelligence) Developer

A BI Developer builds systems that help organizations analyze data and make decisions.

Key Responsibilities:

Develop dashboards, reports, and visualizations

Build ETL pipelines (Extract, Transform, Load)

Model data in warehouses or data marts

Work with business teams to provide insights

Optimize reporting performance



Types of Databases 

Relational vs Non-Relational Databases
What they are

Relational databases store data in structured tables (rows & columns), with a predefined schema. Tables are related via keys (primary / foreign), enabling relationships between data entities. Data is accessed via SQL (Structured Query Language). 
Coursera
+2
insightsoftware
+2

Non-relational databases (often called NoSQL) do not rely on fixed tables/rows. Instead they store data in flexible structures ‚Äî e.g. documents (JSON/BSON), key-value pairs, wide-columns, graphs, etc
| Feature                    | Relational                                                                                               | Non-Relational (NoSQL)                                                                                                           |
| -------------------------- | -------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Schema / Data structure    | Fixed schema, structured tables. ([C# Corner][1])                                                        | Dynamic / schema-less; supports documents, key-value, column-family, graph, etc. ([stackby.com][2])                              |
| Queries & Relationships    | Powerful SQL queries, joins across tables ‚Äî great for relational data. ([insightsoftware][3])            | Often simpler / specialized query mechanisms; relationships possible but less central. ([Secoda][4])                             |
| Transactions & Consistency | Typically supports full ACID transactions, ensuring strong consistency. ([insightsoftware][3])           | Many trade strict consistency for flexibility/performance ‚Äî eventual consistency or tunable consistency. ([stackby.com][2])      |
| Scalability                | Usually scales vertically (bigger server), which may limit scaling at very large loads. ([AppMaster][5]) | Designed for horizontal scaling (across many servers/nodes), handling large or growing data volumes well. ([insightsoftware][3]) |
| Flexibility                | Less flexible: schema changes can be disruptive. ([AlmaBetter][6])                                       | Highly flexible: can evolve data model quickly, handle varying/unstructured data. ([Castor Doc][7])                              |

[1]: https://www.c-sharpcorner.com/article/difference-between-relational-and-non-relational-database/?utm_source=chatgpt.com "What Is The Difference Between Relational And Non-Relational Database"
[2]: https://stackby.com/blog/relational-vs-non-relational-databases/?utm_source=chatgpt.com "Relational vs Non-Relational Databases | What‚Äôs the Difference?"
[3]: https://insightsoftware.com/blog/whats-the-difference-relational-vs-non-relational-databases/?utm_source=chatgpt.com "Relational vs. Non-Relational Databases | insightsoftware"
[4]: https://www.secoda.co/learn/what-are-the-differences-between-relational-and-non-relational-databases?utm_source=chatgpt.com "What Are the Differences Between Relational and Non-Relational Databases? | Secoda"
[5]: https://appmaster.io/blog/relational-vs-non-relational-databases?utm_source=chatgpt.com "Relational vs. Non-Relational Databases | AppMaster"
[6]: https://www.almabetter.com/bytes/articles/difference-between-relational-and-nonrelational-database?utm_source=chatgpt.com "Difference Between Relational and Non Relational Database"
[7]: https://www.castordoc.com/data-strategy/non-relational-database-vs-relational-10-key-differences?utm_source=chatgpt.com "Non-Relational Database vs Relational: 10 Key Differences"

Examples

Relational: common RDBMS such as MySQL, PostgreSQL, Microsoft SQL Server, etc. 
Coursera
+1

Non-relational: e.g. MongoDB (document-store), Apache Cassandra (wide-column store) ‚Äî both are examples of NoSQL DBs. 
stackby.com
+2
Amazon Web Services, Inc.
+2

When to use which (Use-cases)

Relational DB

Use when data is highly structured and relationships matter (e.g. foreign-key relationships). For example: financial systems, banking, accounting, enterprise resource planning (ERP), CRM ‚Äî where consistency and transactions are critical. 
insightsoftware
+1

When you need complex queries, joins, reporting, data integrity, ACID transactions.

Non-Relational (NoSQL) DB

Use when data is unstructured or semi-structured (e.g. JSON documents, user-generated content, logs). 
Global Tech Council
+1

When you need scalability and performance horizontally (e.g. big-data, high-throughput writes/reads). 
Oracle
+2
Global Tech Council
+2

Suitable for fast-evolving data models or flexible schemas ‚Äî e.g. content management systems, user profiles, social media data, IoT data ingestion. 
stackby.com
+1

Examples

Using MongoDB for a social-media backend where each user‚Äôs profile and activity log may differ (flexible schema), or for storing logs/events.

Using Cassandra for a high-volume telemetry or IoT platform, where many events/data points are collected and queried quickly across many machines.

üåê Centralized vs Distributed vs Cloud (Distributed-Cloud) Databases
Definitions & Architecture

Centralized database ‚Äî All data resides in a single database instance, hosted at one location (server, mainframe, data center) and managed centrally. 
Wikipedia
+1

Distributed database ‚Äî Data is spread across multiple servers (nodes), potentially across different physical/geographic locations. The distributed system works as a single logical database for the application. 
Oracle
+2
Educative
+2

Cloud (or Cloud-backed) databases / Cloud-distributed databases ‚Äî A variant of distributed databases that leverage cloud infrastructure: data is stored across cloud servers/data-centers, possibly distributed globally, with managed scalability, replication, and high availability. (Often the ‚Äúdistributed database in the cloud‚Äù model.)

Key trade-offs

Centralized: simpler to manage, consistent data (single point of truth), easier to maintain integrity and integrity constraints. But has a single point of failure; limited scalability; may become bottleneck. 
Wikipedia
+1

Distributed: offers horizontal scalability, high availability (if one node fails others can take over), and can serve globally distributed users with lower latency (by placing nodes closer to users) 
Oracle
+1
. However, complexity rises: data synchronization, consistency across nodes, replication overhead, potential latency. 
Oracle
+1

Cloud / Cloud-distributed: inherits advantages of distributed (scalability, resilience) and adds on-demand resource provisioning, global reach, managed infrastructure ‚Äî reducing the burden of hardware management. Also supports dynamic scaling as usage grows or shrinks.

Use-case Examples

Centralized: small-to-medium organizations, legacy applications, internal systems where traffic and data volume are modest; e.g. a small company‚Äôs HR system, a local university‚Äôs student database, a small business‚Äôs inventory tracking on a single server.

Distributed / Cloud-distributed: large-scale web apps, global applications, high-availability services, big-data platforms. For example: a global e-commerce site with users across continents; a SaaS platform serving users in multiple regions; real-time analytics or logging systems; distributed microservices architectures; global content-delivery systems.

Hybrid cloud / distributed-cloud: companies wanting to scale out as demand grows, while avoiding on-prem hardware overhead. Many modern apps use cloud databases to get scalability + flexibility + resilience.

In particular, distributed databases are often used as the ‚Äúbackend‚Äù for applications that need to handle high throughput, real-time data, or globally distributed user bases.




Cloud Storage and Databases

Cloud Storage

Cloud storage is a service where data is stored on remote servers accessed via the internet, rather than on local physical devices. These servers are hosted and managed by cloud providers such as Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP).

Key Features

Accessible from anywhere through the internet

Highly scalable (storage grows as needed)

Managed security, backups, and maintenance

Pay-as-you-go pricing

Examples

AWS S3

Azure Blob Storage

Google Cloud Storage

Relation Between Cloud Storage and Databases

Cloud storage and cloud databases are related but not the same:

Cloud Storage

Stores files, documents, images, videos, backups, logs, etc.

Not structured like a database.

Cloud Databases

Full database systems hosted in the cloud.

Store structured or semi-structured data.

Support SQL queries, transactions, indexing, etc.

How they relate

Cloud storage can be used to hold backups of cloud databases.

Databases may use cloud storage internally for scaling or durability (e.g., Google Spanner, Snowflake).

Applications often use both:

Cloud Storage for large files

Cloud Database for transactional data

Advantages & Disadvantages of Cloud-Based Databases

Examples include Azure SQL, Amazon RDS, Google Cloud Spanner, MongoDB Atlas, etc.

Advantages
1. Scalability

Automatically adjusts resources (CPU, memory, storage)

Easy to scale up or out based on demand

2. High Availability

Built-in redundancy across regions or zones

Automatic failover

Minimal downtime

3. Managed Maintenance

Cloud providers handle:

Backups

Patching

Updates

Monitoring

This reduces the workload on DBAs.

4. Cost Efficiency

Pay only for what you use

No need to purchase physical servers

Reduces IT overhead

5. Security

Data encryption at rest & in transit

Access control & auditing

Compliance certifications (ISO, GDPR, HIPAA support depending on provider)

6. Global Access

Applications can connect from anywhere

Databases can replicate across regions for low latency

Disadvantages
1. Internet Dependency

Requires a stable internet connection

Latency may affect performance for real-time systems

2. Ongoing Monthly Costs

Costs can increase with:

High storage

High traffic

Cross-region replication

High compute power

3. Limited Control

Users cannot access the physical servers

Some features may not be customizable

Performance tuning is restricted compared to self-hosted databases

4. Vendor Lock-In

Moving from AWS ‚Üí Azure ‚Üí GCP can be difficult

Migration can require rewriting parts of the application

5. Security Risks

Although cloud is secure, it introduces:

Risk of misconfiguration (e.g., public access)

Shared responsibility model

Potential exposure if credentials are leaked

6. Compliance Challenges

Some industries have strict rules:

Healthcare

Finance

Government
May require special configurations or on-premise components.



Database Engines and Languages


A database engine (or database management system engine) is the core software component responsible for:

Storing data

Retrieving data

Processing queries

Ensuring security, concurrency, transactions, and recovery

| Database Engine          | Vendor               | Notes                                                  |
| ------------------------ | -------------------- | ------------------------------------------------------ |
| **Microsoft SQL Server** | Microsoft            | Enterprise-grade RDBMS with strong analytics support   |
| **MySQL**                | Oracle (Open-source) | Popular for web apps (LAMP stack)                      |
| **Oracle Database**      | Oracle               | Highly scalable, used in large enterprise environments |
| **PostgreSQL**           | Open-source          | Known for standards compliance & extensibility         |


| Database Engine | Primary Query Language          | Description                                                   |
| --------------- | ------------------------------- | ------------------------------------------------------------- |
| **SQL Server**  | **T-SQL** (Transact-SQL)        | Microsoft‚Äôs extended version of SQL                           |
| **Oracle DB**   | **PL/SQL**                      | Oracle‚Äôs procedural language extension                        |
| **MySQL**       | **ANSI SQL + MySQL extensions** | More lightweight; uses stored program syntax                  |
| **PostgreSQL**  | **ANSI SQL + PL/pgSQL**         | Very compatible with standards; has many procedural languages |


Is There a Relationship Between the Engine and the Language?

Yes ‚Äî each database engine has its own dialect of SQL.

‚úî What‚Äôs shared?

All engines support ANSI SQL (standard SQL)

Basic commands like:

SELECT, INSERT, UPDATE, DELETE

CREATE TABLE, DROP TABLE

Simple joins and aggregations

‚úî What‚Äôs different?

Each engine adds extra features, such as:

Procedural logic (BEGIN...END, loops, conditions)

Special data types

Functions (string, date, math)

System procedures

Performance hints (e.g., optimizer directives)

Example differences:

SQL Server‚Äôs TOP 10 vs MySQL‚Äôs LIMIT 10 vs Oracle‚Äôs FETCH FIRST 10 ROWS

Oracle uses sequences (my_seq.NEXTVAL), MySQL uses AUTO_INCREMENT.

‚úÖ Can One Language Work Across Different Engines?
‚úî Standard SQL works across all engines‚Ä¶ to a point

Basic SQL queries such as:

SELECT * FROM Customers WHERE Country = 'USA';



‚Ä¶will work in almost any database.

| Language                    | Works Only On |
| --------------------------- | ------------- |
| T-SQL                       | SQL Server    |
| PL/SQL                      | Oracle        |
| PL/pgSQL                    | PostgreSQL    |
| MySQL stored program syntax | MySQL         |


Can We Transfer a Database Between Engines

it is possible to migrate between engines (e.g., SQL Server ‚Üí MySQL, Oracle ‚Üí PostgreSQL, etc.).
However, it is not a simple copy-paste job. Each database engine has its own SQL dialect, storage mechanisms, and internal behavior, which makes migrations challenging.

Challenges of Engine-to-Engine Migration

Migrating databases is difficult because engines behave differently:

A. SQL Dialect Differences

Each DB uses its own language extension:

SQL Server ‚Üí T-SQL

Oracle ‚Üí PL/SQL

PostgreSQL ‚Üí PL/pgSQL

MySQL ‚Üí procedural SQL + limited features

Many features are not compatible, for example:

TOP (SQL Server) vs LIMIT (MySQL/Postgres)

Sequences vs identity columns

MERGE statement behavior differs

Date/time functions (GETDATE(), SYSDATE, etc.)

B. Data Type Mismatches

Not all data types have 1-to-1 equivalents.

Examples:

SQL Server NVARCHAR(MAX) ‚Üí MySQL LONGTEXT

Oracle NUMBER ‚Üí PostgreSQL NUMERIC, INT, or BIGINT

SQL Server DATETIME ‚Üí PostgreSQL TIMESTAMP

Oracle CLOB/BLOB ‚Üí PostgreSQL TEXT/bytea

If mapped incorrectly:
‚úî data loss
‚úî precision errors
‚úî truncated text

C. Constraints & Index Differences

Foreign keys, cascades, unique constraints behave differently.

Index types differ (e.g., PostgreSQL GIN/GIST indexes).

Oracle/Postgres can enforce more strict constraint validation.

D. Stored Procedure & Trigger Rewrites

This is the most difficult part.

Every engine has different syntax for:

loops

exceptions

variable declarations

cursors

trigger timing events

built-in functions

Example:

SQL Server T-SQL procedure:

DECLARE @x INT = 10;
SET @x = @x + 1;


PostgreSQL PL/pgSQL equivalent:

x := x + 1;


Full stored procedure rewrites may be required.

E. Views, Functions & Packages

View definitions may use non-portable functions.

Oracle Packages have no direct equivalent in many engines.

PostgreSQL schemas behave differently from Oracle schemas.

F. Transactions & Isolation Levels

PostgreSQL uses MVCC differently from Oracle.

MySQL InnoDB handles locking differently from SQL Server.

Some transaction modes may not exist in other engines.

G. Performance Considerations

Execution plans, indexes, caching, and optimizers differ:
‚úî Queries must be re-tuned
‚úî Index strategies redesigned
‚úî Large tables may require partitioning changes

üß≠ 3. What to Consider Before Migrating

To avoid failures and downtime, consider these areas:

A. Schema Compatibility Checklist
‚úî Data Types

Map every type manually:

CHAR, VARCHAR, TEXT

INT, BIGINT, DECIMAL

DATETIME, DATE, TIMESTAMP

BLOB/CLOB/IMAGE

ENUM / SET (MySQL only)

| Object Type        | Migration Notes                 |
| ------------------ | ------------------------------- |
| Tables             | Data type rewrite needed        |
| Views              | Rebuild using new SQL syntax    |
| Stored Procedures  | 80‚Äì100% rewritten               |
| Functions          | Rewrite required                |
| Triggers           | Rewrite logic + syntax          |
| Indexes            | Strategy differs per engine     |
| Sequences/Identity | Map to AUTO_INCREMENT or SERIAL |
| Constraints        | Ensure referential integrity    |

C. Application Dependencies

The application may use:

SQL queries embedded in code

ORM (Hibernate, EF, Django ORM)

Driver-specific features

Custom transaction logic

These must be updated and tested.

D. Performance Planning

Re-indexing strategy

Query optimization

Partitioning changes

Statistics and caching behavior

Hardware differences (RAM/disk)

E. Migration Strategy

Decide on approach:

1. Full Dump & Restore

Good for small databases
Fast, simple, downtime required.

2. Incremental + Live Migration

Used for production systems:

Replication

Change data capture (CDC)

Cut-over window minimized

3. Hybrid (ETL + Rebuild)

For large or incompatible systems.



Logical vs. Physical Schema

A Logical Schema describes the structure of the data independent of how it will physically be stored.
It is conceptual and focuses on business requirements and relationships, not hardware or storage details.

It includes:

Entities (e.g., Student, Course, Instructor)

Attributes (name, ID, date of birth, etc.)

Relationships (Student ‚Üí Enrolls ‚Üí Course)

Constraints (primary keys, foreign keys, cardinality)

Key idea:

üëâ It is about what the data means.

‚úÖ What is a Physical Schema?

A Physical Schema defines how data is actually stored in the database engine.

This includes:

Table structures in SQL

Data types (VARCHAR, INT, DATE‚Ä¶)

Indexes

Partitioning

File organization and storage parameters

Performance constraints (e.g., clustering, sharding)

| Feature        | Logical Schema                      | Physical Schema                              |
| -------------- | ----------------------------------- | -------------------------------------------- |
| Focus          | Business-level structure            | Technical implementation                     |
| Independence   | Independent of software/hardware    | Depends on DBMS (MySQL, Oracle, PostgreSQL‚Ä¶) |
| Includes       | Entities, attributes, relationships | Tables, columns, types, indexes              |
| Concerned with | What data is stored                 | How data is stored and optimized             |
| Audience       | Analysts, designers                 | Database developers, DBAs                    |


Why is it Important to Understand Both?

Understanding both schemas ensures:

1. Clear separation of business logic from technical implementation

Analysts design what is needed

DBAs decide how it is stored efficiently

2. Flexibility

Logical schema stays the same even if:

You migrate from SQL Server ‚Üí MySQL

You change hardware

You modify indexing

3. Performance Optimization

Physical schema supports:

Fast queries

Index tuning

Storage efficiency

Scaling

4. Better communication

Logical schema ‚Üí Business understanding
Physical schema ‚Üí Developer/DBA understanding
Example: Student Entity (Logical vs Physical Schema)
| Attribute      | Description          |
| -------------- | -------------------- |
| StudentID      | Unique identifier    |
| FirstName      | Student‚Äôs first name |
| LastName       | Student‚Äôs last name  |
| DOB            | Date of birth        |
| Email          | Contact email        |
| EnrollmentDate | Date student joined  |

2. Physical Schema (Implementation in SQL)

Here‚Äôs how the same entity becomes a table in a database:

CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    FirstName VARCHAR(50) NOT NULL,
    LastName VARCHAR(50) NOT NULL,
    DOB DATE,
    Email VARCHAR(100) UNIQUE,
    EnrollmentDate DATE,
    INDEX idx_lastname (LastName)
);

